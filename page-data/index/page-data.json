{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"Andy Diary"}},"allMarkdownRemark":{"nodes":[{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/java-concurrency/04/index.md","excerpt":"如何造成死鎖 基本上要造成死鎖的條件有四個，如下說明 禁止搶占: 已經分配的資源不能被強制性釋放。 持有與等待: 執行緒已經持有了至少一個資源，並且正在等待獲取其他資源。 互斥: 至少有一個資源被設置成了互斥狀態，即一次只能由一個執行緒訪問。 循環等待: 存在一個等待循環，即執行緒A正在等待執行緒B持有的資源，執行緒B…","fields":{"slug":"/java-concurrency/04/"},"frontmatter":{"date":"2023-04-16","title":"Java Concurrency #04 - 如何造成死鎖以及解決方法"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/java-concurrency/03/index.md","excerpt":"為何需要鎖(Lock) 為了防止競爭條件(Race condition)，我們是需要加上 Lock 使其他 Thread 無法同時存取該資源，而 Lock 的作用就是提供一個同步的機制，也因如此我們可以確保 Multi thread 情況下不會互相干擾。 物件鎖(Object Lock) Object lock…","fields":{"slug":"/java-concurrency/03/"},"frontmatter":{"date":"2023-04-14","title":"Java Concurrency #03 - 關於 synchronized lock 的那點事"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/java-concurrency/02/index.md","excerpt":"可見性、原子性和有序性是多線程編程中的三個重要概念，它們是保證多線程程序正確性的三個基本要素。 可見性 在 Multi thread 中，可見性是指當一個 Thread 修改共享變量的值時，該修改對其他 Thread 是否可見的問題。如果修改對其他 Thread…","fields":{"slug":"/java-concurrency/02/"},"frontmatter":{"date":"2023-04-08","title":"Java Concurrency #02 - 可見性、原子性、有序性"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/java-concurrency/01/index.md","excerpt":"在講解 Concurrency 時，我們有必要去理解 Thread 相關知識，因此在此篇文章中，我們講快速理解一遍關於 Thread 的那些事。 什麼是 Thread 要講 Thread 我們就得先談到 Process，我們每一個運行的程序就可稱為為 Process，而 Thread 是 Process…","fields":{"slug":"/java-concurrency/01/"},"frontmatter":{"date":"2023-04-03","title":"Java Concurrency #01 - Thread 的基礎觀念"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/development/玩玩 Completablefuture/index.md","excerpt":"Git項目位置: https://github.com/Kuan-Wei-Kuo/completablefuture-demo Java 8 開始引入 Completablefuture，基本上就是針對 Future 進行加強，我們可以在非同步任務完成或發生異常時，自動調用 Callback…","fields":{"slug":"/development/玩玩 Completablefuture/"},"frontmatter":{"date":"2023-04-01","title":"玩玩 Completablefuture"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/elk/要不要來點 ELK - Kibana/index.md","excerpt":"Git項目位置: https://github.com/Kuan-Wei-Kuo/elk-demo 什麼是 Kinaba ? Kinana 簡單的說就是一個視覺化工具，但其中還新增了許多與 Elasticsearch 進行設定的功能，來方便我們對 ES 進行操作。 出來吧 ! Kibana…","fields":{"slug":"/elk/要不要來點 ELK - Kibana/"},"frontmatter":{"date":"2023-03-25","title":"要不來點 ELK - Kibana"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/elk/要不要來點 ELK - Elasticsearch/index.md","excerpt":"Git項目位置: https://github.com/Kuan-Wei-Kuo/elk-demo 什麼是 Elasticsearch ? Elasticsearch 是一套開源且基於 Apache lucene 的分散式搜尋引擎，因此搜尋效能非常好。通常我們會將資料儲放到 Elasticsearch…","fields":{"slug":"/elk/要不要來點 ELK - Elasticsearch/"},"frontmatter":{"date":"2023-03-18","title":"要不來點 ELK - Logstash(Indexer) with Elasticsearch"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/elk/要不要來點 ELK - Logstash/index.md","excerpt":"Git項目位置: https://github.com/Kuan-Wei-Kuo/elk-demo 什麼是 Logstash ? Logstash 是一個資料處理管道，其從多個來源攝取資料以及轉換，後續將會傳送資料至我們喜歡的存儲位置。 從上述我們也可以切分成三塊，正好是 Logstash…","fields":{"slug":"/elk/要不要來點 ELK - Logstash/"},"frontmatter":{"date":"2023-03-13","title":"要不來點 ELK - Logstash(Shipper)"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/elk/要不要來點 ELK - Filebeat/index.md","excerpt":"Git項目位置: https://github.com/Kuan-Wei-Kuo/elk-demo 什麼是 Filebeat ? 如果我們去 Filebeat 介紹頁面，會看看斗大的 Lightweight shipper for logs 字眼，意思就是說 Filebeat…","fields":{"slug":"/elk/要不要來點 ELK - Filebeat/"},"frontmatter":{"date":"2023-03-07","title":"要不來點 ELK - Filebeat"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/elk/要不來點 ELK/index.md","excerpt":"Git項目位置: https://github.com/Kuan-Wei-Kuo/elk-demo 什麼是 ELK ? ELK 是個縮寫，其描述由三個熱門專案所組成的堆疊，分別為 Elasticsearch、Logstash、Kibana，通常使用在彙總所有系統和服務的 Log…","fields":{"slug":"/elk/要不來點 ELK/"},"frontmatter":{"date":"2023-02-26","title":"要不來點 ELK"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/docker/Docker container 所造成的硬碟空間不足/index.md","excerpt":"事情是這樣的 在某年某月某一天，同事跑來跟我說測試機的 Docker Host 容量爆炸啦! 我第一步先打開 Docker Host 確認狀況，發現 Container 數量並沒不多，並且使用下面指令查詢 Docker 空間分佈: 得到的答案讓我覺得事情精彩了，Container、Image、Volume…","fields":{"slug":"/docker/Docker container 所造成的硬碟空間不足/"},"frontmatter":{"date":"2023-02-21","title":"Docker container 所造成的硬碟空間不足"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/development/談談 JVM 的 Stack 與 Heap/index.md","excerpt":"在 JAVA 中管理記憶管理分為兩部分，分別為 Stack 與 Heap，各自有著不同的負責項目，也需要相互合作，接下來就讓我們探討兩者之前的差別。 Stack Memory 在 JVM 中 Stack 儲存順序為後進先出(LIFO)，每個 thraed 都維護著自有的 Stack…","fields":{"slug":"/development/談談 JVM 的 Stack 與 Heap/"},"frontmatter":{"date":"2023-02-10","title":"談談 JVM 的 Stack 與 Heap"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/leetcode/LeetCode 1115.  Print FooBar Alternately/index.md","excerpt":"題目位置 https://leetcode.com/problems/print-foobar-alternately/ 題目描述 Suppose you are given the following code: 假設你有以下程式碼 The same instance of FooBar will be passed…","fields":{"slug":"/leetcode/LeetCode 1115.  Print FooBar Alternately/"},"frontmatter":{"date":"2023-02-03","title":"LeetCode 1115.  Print FooBar Alternately"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/development/淺談樂觀鎖與實戰/index.md","excerpt":"在上一篇我們談過了悲觀鎖的實際應用，與悲觀鎖不同的是，樂觀鎖並沒有對資料進行上鎖動作，我們允許同時進行對該筆的修改，也因此有可能造成資料不符合預期結果的問題產生。 樂觀鎖 樂觀鎖(Optimistic Locking…","fields":{"slug":"/development/淺談樂觀鎖與實戰/"},"frontmatter":{"date":"2023-01-28","title":"淺談樂觀鎖與實戰"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/development/淺談悲觀鎖與實戰/index.md","excerpt":"在大量請求下，在業務上容易發生併發情況，如果不好好保持資料原子性，那麼我們的資料最終結果並不可信，可以想像若在與金流相關系統上發生這種問題，這將是個災難。 其實說白了，就是要避免競爭條件(Race condition)。 悲觀鎖 悲觀鎖(Pessimistic Locking…","fields":{"slug":"/development/淺談悲觀鎖與實戰/"},"frontmatter":{"date":"2023-01-22","title":"淺談悲觀鎖與實戰"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/leetcode/LeetCode 695. Max Area of Island/index.md","excerpt":"題目位置 https://leetcode.com/problems/max-area-of-island/description/ 題目描述  You are given an  binary matrix . An island is a group of 1's (representing land…","fields":{"slug":"/leetcode/LeetCode 695. Max Area of Island/"},"frontmatter":{"date":"2023-01-04","title":"LeetCode 695. Max Area of Island"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/algorithm/Algorithm. 快速排序(Quicksort)/index.md","excerpt":"基本上 Quicksort 使用 Divide and conquer 策略，將一個 List 進行切割為兩個子序列，只要我們不斷地遞迴這兩個子序列，我們就能夠快速的排序。 步驟 挑選從數列中挑選基準值 (Pivot…","fields":{"slug":"/algorithm/Algorithm. 快速排序(Quicksort)/"},"frontmatter":{"date":"2022-12-17","title":"Algorithm. 快速排序(Quicksort)"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/design-pattern/DesignPattern. 責任鏈模式(Chain Of Responsibility)/index.md","excerpt":"責任鏈模式(Chain Of Responsibility) 責任鏈模式基本上是由一個命令對象與處理對象組成，每一個處理對象都將執行一個命令並且呼叫下一個處理對象，以達到鏈結的效果。 例子 我們需要一個處理器介面類別 接下來，我們需要建立幾個簡單的處理器，並且印出相關字串。 我們有了One、Two、Three…","fields":{"slug":"/design-pattern/DesignPattern. 責任鏈模式(Chain Of Responsibility)/"},"frontmatter":{"date":"2022-12-03","title":"DesignPattern. 責任鏈模式(Chain Of Responsibility)"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/development/CSRF Token 在 Stateless 中所造成的競爭條件/index.md","excerpt":"往往我們在 Spring Security 中要進行無狀態的服務撰寫時，將會設置 SessionCreationPolicy.STATELESS 使 Spring Security 不會產生 Session，然而在 Spring CSRF 防範的機制中，這樣的設定將會造成每個請求都會 Rotated CSRF…","fields":{"slug":"/development/CSRF Token 在 Stateless 中所造成的競爭條件/"},"frontmatter":{"date":"2022-11-13","title":"CSRF Token 在 Stateless 中所造成的競爭條件"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/重拾初衷/index.md","excerpt":"在這幾年，工作戰戰兢兢，慢慢地開始幹著 TM 相關的工作，可是卻也沒掛 TM…","fields":{"slug":"/重拾初衷/"},"frontmatter":{"date":"2022-11-09","title":"重拾初衷"}}]}},"pageContext":{}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}