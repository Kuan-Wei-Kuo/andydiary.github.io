{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"Andy Diary"}},"allMarkdownRemark":{"nodes":[{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/【Java】談談 Stack 與 Heap 的生活/index.md","excerpt":"在 JAVA 中管理記憶管理分為兩部分，分別為 Stack 與 Heap，各自有著不同的負責項目，也需要相互合作，接下來就讓我們探討兩者之前的差別。 Stack Memory 在 JVM 中 Stack 儲存順序為後進先出(LIFO)，每個 thraed 都維護著自有的 Stack…","fields":{"slug":"/【Java】談談 Stack 與 Heap 的生活/"},"frontmatter":{"date":"2023-02-10","title":"【Java】談談 JVM 的 Stack 與 Heap"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/leetcode/【LeetCode】 1115.  Print FooBar Alternately/index.md","excerpt":"題目位置 https://leetcode.com/problems/print-foobar-alternately/ 題目描述 Suppose you are given the following code: 假設你有以下程式碼 The same instance of FooBar will be passed…","fields":{"slug":"/leetcode/【LeetCode】 1115.  Print FooBar Alternately/"},"frontmatter":{"date":"2023-02-03","title":"【LeetCode】 1115.  Print FooBar Alternately"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/淺談樂觀鎖與實戰/index.md","excerpt":"在上一篇我們談過了悲觀鎖的實際應用，與悲觀鎖不同的是，樂觀鎖並沒有對資料進行上鎖動作，我們允許同時進行對該筆的修改，也因此有可能造成資料不符合預期結果的問題產生。 樂觀鎖 樂觀鎖(Optimistic Locking…","fields":{"slug":"/淺談樂觀鎖與實戰/"},"frontmatter":{"date":"2023-01-28","title":"淺談樂觀鎖與實戰"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/淺談悲觀鎖與實戰/index.md","excerpt":"在大量請求下，在業務上容易發生併發情況，如果不好好保持資料原子性，那麼我們的資料最終結果並不可信，可以想像若在與金流相關系統上發生這種問題，這將是個災難。 其實說白了，就是要避免競爭條件(Race condition)。 悲觀鎖 悲觀鎖(Pessimistic Locking…","fields":{"slug":"/淺談悲觀鎖與實戰/"},"frontmatter":{"date":"2023-01-22","title":"淺談悲觀鎖與實戰"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/leetcode/【LeetCode】695. Max Area of Island/index.md","excerpt":"題目位置 https://leetcode.com/problems/max-area-of-island/description/ 題目描述  You are given an  binary matrix . An island is a group of 1's (representing land…","fields":{"slug":"/leetcode/【LeetCode】695. Max Area of Island/"},"frontmatter":{"date":"2023-01-04","title":"【LeetCode】695. Max Area of Island"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/【演算法筆記】快速排序(Quicksort)/index.md","excerpt":"基本上 Quicksort 使用 Divide and conquer 策略，將一個 List 進行切割為兩個子序列，只要我們不斷地遞迴這兩個子序列，我們就能夠快速的排序。 步驟 挑選從數列中挑選基準值 (Pivot…","fields":{"slug":"/【演算法筆記】快速排序(Quicksort)/"},"frontmatter":{"date":"2022-12-17","title":"【演算法筆記】快速排序(Quicksort)"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/【Design Pattern】責任鏈模式(Chain Of Responsibility)/index.md","excerpt":"責任鏈模式(Chain Of Responsibility) 責任鏈模式基本上是由一個命令對象與處理對象組成，每一個處理對象都將執行一個命令並且呼叫下一個處理對象，以達到鏈結的效果。 例子 我們需要一個處理器介面類別 接下來，我們需要建立幾個簡單的處理器，並且印出相關字串。 我們有了One、Two、Three…","fields":{"slug":"/【Design Pattern】責任鏈模式(Chain Of Responsibility)/"},"frontmatter":{"date":"2022-12-03","title":"【Design Pattern】責任鏈模式(Chain Of Responsibility)"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/CSRF Token 在 Stateless 中所造成的競爭條件/index.md","excerpt":"往往我們在 Spring Security 中要進行無狀態的服務撰寫時，將會設置 SessionCreationPolicy.STATELESS 使 Spring Security 不會產生 Session，然而在 Spring CSRF 防範的機制中，這樣的設定將會造成每個請求都會 Rotated CSRF…","fields":{"slug":"/CSRF Token 在 Stateless 中所造成的競爭條件/"},"frontmatter":{"date":"2022-11-13","title":"CSRF Token 在 Stateless 中所造成的競爭條件"}},{"fileAbsolutePath":"D:/GitHub/andydiary.github.io/content/blog/重拾初衷/index.md","excerpt":"在這幾年，工作戰戰兢兢，慢慢地開始幹著 TM 相關的工作，可是卻也沒掛 TM…","fields":{"slug":"/重拾初衷/"},"frontmatter":{"date":"2022-11-09","title":"重拾初衷"}}]}},"pageContext":{}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}