{"componentChunkName":"component---src-templates-blog-post-js","path":"/淺談負載均衡 Webscoket 消息共享問題/","result":{"data":{"site":{"siteMetadata":{"title":"Andy Diary"}},"markdownRemark":{"id":"5989e371-09fd-59cc-8a75-2f81f794dce6","excerpt":"前提 現代系統搭配負載均衡的服務越來越多，如果服務需要搭配 Websocket 功能，每個服務訂閱的真實位置可能都不同，那麼我們如何共享服務的消息。 解決思路 假設我們今天有一個廣告服務，廣告成立後要使用 Websocket 通知各個 Client 端，而廣告服務又被 Replicas…","html":"<h2>前提</h2>\n<p>現代系統搭配負載均衡的服務越來越多，如果服務需要搭配 Websocket 功能，每個服務訂閱的真實位置可能都不同，那麼我們如何共享服務的消息。</p>\n<h2>解決思路</h2>\n<p>假設我們今天有一個廣告服務，廣告成立後要使用 Websocket 通知各個 Client 端，而廣告服務又被 Replicas 多個。按照上述場景，我們是無法得知 Client 訂閱了哪一個服務，除非我們後端成功建立常連接後進行 IP、Session 的緩存，才能夠得知 Client 真實訂閱哪個服務。</p>\n<blockquote>\n<ol>\n<li>廣播群體使用者</li>\n</ol>\n</blockquote>\n<p>整體來說我們可將所有要廣播的消息丟到 MQ 裡，這時候我們可以選擇 Client 是否直接要訂閱 MQ，又或者想將 MQ 隱藏起來，由服務在接收一次 MQ 資料，進行 Websocket 廣播，流程圖如下。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/57ac0faedf96fcf0bb8ba84fbc92b247/5205c/Websocket%E5%85%B1%E4%BA%AB.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.911392405063296%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABMklEQVR42m2R6UoDQRCE9/1fy/tCEPwTUIOJJtnZY+7sXPtJJoqKFhQ9MNXdVHUzc8RX/Yl5/mR9/6c4Yh8K6z4ymETz3QlO7wkhEGMk5/x78qHRTMheoY1Ga42UkpQCoyvcLwNPu0DTXV1g7u8wb2vazYBoBUIIlDJkt8JsL/HimuRekYNBjQrnHNZatDZYo2lHz2IHr32mCZ0g9R157/9YKcmSJ0GZOlLUdLuRzXqLEC1t29bBKQY6NXH6sGHxZmgohTln5jIjO103H4QH68f0Csz5O+V/olS+cLsYed7uadqzE9TNFWa1Yhg0cpQ1G2M9yS7Rm1Pc9pxgXtDK13+lVKX3nhgmOhV4fJ9ZikSTrSU7S4nx75VLqLYPhIiVnrFXWGerk5RS1U2x8D4kRpv5AN8jHP6K76s4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Websocket共享\"\n        title=\"\"\n        src=\"/static/57ac0faedf96fcf0bb8ba84fbc92b247/f058b/Websocket%E5%85%B1%E4%BA%AB.png\"\n        srcset=\"/static/57ac0faedf96fcf0bb8ba84fbc92b247/c26ae/Websocket%E5%85%B1%E4%BA%AB.png 158w,\n/static/57ac0faedf96fcf0bb8ba84fbc92b247/6bdcf/Websocket%E5%85%B1%E4%BA%AB.png 315w,\n/static/57ac0faedf96fcf0bb8ba84fbc92b247/f058b/Websocket%E5%85%B1%E4%BA%AB.png 630w,\n/static/57ac0faedf96fcf0bb8ba84fbc92b247/5205c/Websocket%E5%85%B1%E4%BA%AB.png 833w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<blockquote>\n<ol start=\"2\">\n<li>廣播個別使用者</li>\n</ol>\n</blockquote>\n<p>思路大體上是一樣的，只是這時候我們需要儲存同個 User 不同裝置的 Session ID，並且利用 Spring websocket 中的 setUserDestinationPrefix、convertAndSendToUser 來幫助我們廣播到個別使用者身上。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/16d6b8bb8891327558dce0bf89f94079/5205c/Websocket%E5%85%B1%E4%BA%AB_%E5%96%AE%E9%BB%9E.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.46835443037975%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkElEQVR42m2RzW7UMBSF89C8BBJvgIQQO1ixYUE3VLCoqmoY0aLSv1Epk5nMdJJxYsdJHPv6Q5OWgjIc6Sx8fXzuvcdJDIHoPTF4xAdMaWnblqZpCLs78Yg4YvQEL5S5xtSGurYYY+h7h+2E66znvvIkbv6L7ckxZjrBZBn5pkQphVIljTVgZrj7MzA31FpTbBRa64FlVWFMxaqwnM4988KTSNsSjB64m3SMeT7lPD3gcnFIbQzrRU5RFAN3W0QJbE3P+cKzVJ5kbBBjHChRhvPBxRteHj3j7fQ5LrRPmn9RNcKPTFiqQDIYiDzw0ezPgyCeTK25Xaasyhx5rI91qvZ8OV1yt272Jxxjmh7y8eI1n67e4cVB3DcsbeDrTJMWjkS6Fq93GRpC51Cbagi8qioQmNy+58O3F3y+fIWX7r9NKxv+ruzufrI9PkJPTqizDG0aGmuHwLvWgrnGb87AzrBGk6/VU0PbNPjeUWjH99STbv1+huMPEglDlhIDwQe0qqnrB/Z9P+jqLnCz6sl14De177LD7H1bGwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Websocket共享(單點)\"\n        title=\"\"\n        src=\"/static/16d6b8bb8891327558dce0bf89f94079/f058b/Websocket%E5%85%B1%E4%BA%AB_%E5%96%AE%E9%BB%9E.png\"\n        srcset=\"/static/16d6b8bb8891327558dce0bf89f94079/c26ae/Websocket%E5%85%B1%E4%BA%AB_%E5%96%AE%E9%BB%9E.png 158w,\n/static/16d6b8bb8891327558dce0bf89f94079/6bdcf/Websocket%E5%85%B1%E4%BA%AB_%E5%96%AE%E9%BB%9E.png 315w,\n/static/16d6b8bb8891327558dce0bf89f94079/f058b/Websocket%E5%85%B1%E4%BA%AB_%E5%96%AE%E9%BB%9E.png 630w,\n/static/16d6b8bb8891327558dce0bf89f94079/5205c/Websocket%E5%85%B1%E4%BA%AB_%E5%96%AE%E9%BB%9E.png 833w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>結論</h2>\n<p>除了這次分享的方式除外，我們還可以使用Redis、Database 都可以實現這種效果。當然這次的分享還是簡單了，但安迪我也不愛寫太長的文章，又臭又長，寫了也是挺累了。</p>","frontmatter":{"title":"淺談負載均衡 Webscoket 消息共享問題","date":"2023-09-05","description":null}},"previous":{"fields":{"slug":"/SpringBootTest 如何跳過 @Configuration/"},"frontmatter":{"title":"SpringBootTest 如何跳過 @Configuration"}},"next":null},"pageContext":{"id":"5989e371-09fd-59cc-8a75-2f81f794dce6","previousPostId":"033928fa-b884-5291-9f3d-914c35f5d226","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}